https://codemirror.net/docs/migration/

这份文档的核心思想是：CodeMirror 6 在设计哲学上与 CodeMirror 5 有着根本性的不同。它从一个**一体化、命令式**的库，转变为一个**模块化、声明式、基于函数式思想**的系统。理解这一转变是掌握新版本的关键。

下面我将按照原文的结构，为你逐一解析其中的关键变化点：

### 1. 核心架构转变：从一体化到模块化

- **过去 (v5)**: 一个庞大的 `codemirror.js` 文件（或几个核心文件），通过 `<script>` 标签加载，所有功能都挂载在一个全局的 CodeMirror 对象上。
- **现在 (v6)**: 整个库被拆分成众多独立的 NPM 包（例如 `@codemirror/view`, `@codemirror/state`, `@codemirror/lang-javascript`）。你必须使用构建工具（如 Webpack, Rollup, Vite）来打包这些 ES 模块。
- **关键点**: 这种改变让你能做到**按需加载**，最终打包体积可以非常小。你只引入你真正需要的功能，而不是加载一个包含所有功能的巨大库。

### 2. 编辑器创建：从“选项”到“扩展”

- **过去 (v5)**: `CodeMirror(domElement, { lineNumbers: true, mode: "javascript" })`，通过一个巨大的配置对象来初始化。
- **现在 (v6)**: 编辑器的**状态 (State)** 和**视图 (View)** 是分离的。
  1.  你用一个**扩展 (extensions)** 数组来描述编辑器的所有功能（包括内容、快捷键、主题、语言等）。
  2.  用这个扩展数组创建 `EditorState`。
  3.  用这个 `EditorState` 创建 `EditorView`，并挂载到 DOM 上。
- **关键点**: v6 的配置是**可组合的**。所有功能，无论是行号、撤销历史还是语法高亮，都是平等的“扩展”。你可以像搭乐高一样自由组合它们。

### 3. 定位方式：从 `{line, ch}` 到 `offset`

- **过去 (v5)**: 使用 `{line: 行号, ch: 字符位置}` 对象来表示文档中的一个点。
- **现在 (v6)**: 使用单一的数字**偏移量 (offset)**，即从文档开头算起的字符数。
- **关键点**: 使用数字进行计算和传递远比操作对象更高效、更简单。文档提供了 `posToOffset` 和 `offsetToPos` 两个转换函数来帮助迁移。**注意：v6 的行号从 1 开始，而 v5 从 0 开始。**

### 4. 状态获取：从直接方法到 state 对象

- **过去 (v5)**: 通过 `cm.getValue()`、`cm.getCursor()` 等方法直接从编辑器实例上获取信息。
- **现在 (v6)**: 所有状态信息都统一存放在 `view.state` 对象中。例如 `view.state.doc.toString()` 获取文档，`view.state.selection.main.head` 获取光标位置。
- **关键点**: `view.state` 是一个**不可变 (immutable)** 的数据结构。任何改动都不会修改它，而是会生成一个新的 state 对象。这使得状态管理更可预测。

### 5. 内容变更：从命令式调用到“事务”分发

- **过去 (v5)**: 调用 `cm.replaceRange(...)` 或 `cm.setValue(...)` 等方法直接修改编辑器。
- **现在 (v6)**: 所有变更都必须通过**事务 (Transaction)** 来描述，然后通过 `view.dispatch({ ... })` 方法来分发。
  - 要修改文档，你创建一个包含 `changes` 属性的事务。
  - 要修改选区，你创建一个包含 `selection` 属性的事务。
- **关键点**: 这是 v6 最核心的理念。将所有变更（文档修改、选区移动等）打包在一个事务中，可以保证它们被**原子性地**应用。这彻底解决了 v5 中需要用 `operation` 来组合多个操作的复杂性。

### 6. 配置更新：从 `setOption` 到 `Compartment`

- **过去 (v5)**: 使用 `cm.setOption("tabSize", 4)` 动态修改配置。
- **现在 (v6)**: 动态配置需要使用 `Compartment`（隔间）。
  1.  创建一个 `Compartment` 实例。
  2.  在初始扩展中，使用 `myCompartment.of(...)` 来包裹那部分可变的配置。
  3.  之后，通过 `view.dispatch({ effects: myCompartment.reconfigure(...) })` 来分发一个“重新配置”的事务。
- **关键点**: 这种方式虽然更繁琐，但它使得配置的变更也融入了事务系统，让状态的每一次变化都有迹可循。

### 7. 事件系统：从事件监听到状态派生

- **过去 (v5)**: 使用 `cm.on("change", ...)` 来监听变化并做出反应。
- **现在 (v6)**: **完全移除了事件系统**。取而代之的是：
  - **StateField**: 如果你需要维护一个与编辑器状态同步的自定义状态，可以创建自己的 `StateField`。它有一个 `update` 方法，会在每次事务发生时被调用，让你根据事务计算出新的自定义状态。
  - **ViewPlugin / updateListener**: 如果你需要在每次视图更新时执行某些操作（例如操作 DOM），可以使用视图插件或更新监听器。
- **关键点**: v6 认为异步的事件回调难以维护和组合。通过 `StateField` 的“reducer”模式，你的逻辑可以更健壮、更紧密地与编辑器状态的原子更新保持一致。

### 8. 标记文本：从 `markText` 到 `Decoration`

- **过去 (v5)**: 调用 `cm.markText(...)` 来给文本添加样式或创建书签，这是一个副作用操作。
- **现在 (v6)**: 标记文本被称为**装饰 (Decorations)**。你不能直接添加或删除它们。你必须：
  1.  创建一个 `StateField` 来管理一个 `DecorationSet`（装饰集合）。
  2.  这个 `StateField` 的 `update` 函数负责在每次事务后更新这个集合。
  3.  通过 `provide` 属性告诉编辑器，这个字段提供了装饰物。
  4.  通过分发一个带有自定义**效果 (Effect)** 的事务，来“通知”你的 `StateField` 去添加或移除装饰。
- **关键点**: 这是 v6 声明式思想的极致体现。你不是去“做”一个标记，而是去“声明”在某个状态下应该存在哪些标记。这种方式虽然初看起来很复杂，但它极其强大和稳健，能避免很多 v5 中因时序问题导致的 bug。

### 总结

| 特性     | CodeMirror 5 (旧)           | CodeMirror 6 (新)                         | 核心思想                 |
| :------- | :-------------------------- | :---------------------------------------- | :----------------------- |
| **架构** | 一体化，全局对象            | 模块化，NPM 包                            | 按需加载，现代前端工作流 |
| **配置** | 单个配置对象                | 可组合的 `extensions` 数组                | 声明式，功能即扩展       |
| **状态** | 可变的，通过方法访问        | 不可变的 state 对象                       | 函数式，可预测           |
| **变更** | 命令式方法 (`replaceRange`) | 原子性的 `dispatch(transaction)`          | 保证数据一致性           |
| **事件** | `on("change")` 事件系统     | 无事件，使用 `StateField` 和 `ViewPlugin` | 状态驱动，而非事件驱动   |
| **标记** | `markText()` 副作用         | `Decoration` 状态字段                     | 声明式 UI                |

迁移到 CodeMirror 6 确实有学习曲线，因为它要求你用一种全新的、更接近 React 等现代框架的思维方式来思考编辑器。但一旦掌握，你将获得一个更强大、更可靠、性能更好的基础平台。
